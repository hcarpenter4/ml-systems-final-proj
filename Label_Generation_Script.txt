Below is the JS script I used in the Google Chrome DevTools terminal to extract 
the video resolution labels from Netflix. This script was generated by ChatGPT.


// === QoE logger 0.1 ===
// Usage:
// 1 Paste this into the Console and press Enter.
// 2 Start playback, then run `startQoE(250)` to sample every 250 ms.
// 3 Stop with `stopQoE()` and download CSV with `downloadQoE()`.

(function(){
  if (window.__qoeLogger) {
    console.warn("QoE logger already defined. Use startQoE(), stopQoE(), downloadQoE().");
    return;
  }

  // storage
  window.__qoeLogger = {
    running: false,
    samples: [],
    intervalId: null
  };

  // helper: safe get video element (first visible HTMLVideoElement)
  function getVideo() {
    const vids = Array.from(document.querySelectorAll('video'));
    // prefer visible / playing video
    for (const v of vids) {
      // check rendered size > 0
      if (v.offsetWidth > 0 && v.offsetHeight > 0) return v;
    }
    return vids[0] || null;
  }

  // helper: try the standard API for decoded/dropped frames
  function readPlaybackQuality(v) {
    try {
      if (!v) return null;
      // standardized API (may be supported)
      const q = v.getVideoPlaybackQuality && v.getVideoPlaybackQuality();
      if (q && typeof q.totalVideoFrames === 'number') return {
        totalVideoFrames: q.totalVideoFrames,
        droppedVideoFrames: q.droppedVideoFrames ?? null,
        creationTime: q.creationTime ?? null
      };
    } catch(e){
      // ignore and fallback
    }
    // fallback: some players expose fields on the video element
    return {
      totalVideoFrames: v.webkitDecodedFrameCount ?? v.mozDecodedFrames ?? null,
      droppedVideoFrames: v.webkitDroppedFrameCount ?? null,
      creationTime: null
    };
  }

  // core sampler (collects one sample)
  function takeSample() {
    const v = getVideo();
    const now_ms = Date.now(); // wallclock in ms
    const sample = {
      timestamp_ms: now_ms,
      iso: new Date(now_ms).toISOString()
    };

    if (!v) {
      sample.note = "no_video_element";
      window.__qoeLogger.samples.push(sample);
      return;
    }

    // basic playback properties
    sample.currentTime_s = typeof v.currentTime === 'number' ? v.currentTime : null;
    sample.duration_s = typeof v.duration === 'number' && isFinite(v.duration) ? v.duration : null;
    sample.paused = !!v.paused;
    sample.playbackRate = v.playbackRate ?? null;
    sample.readyState = v.readyState ?? null;
    sample.videoWidth = v.videoWidth ?? null;
    sample.videoHeight = v.videoHeight ?? null;

    // codec/playback-level stats (decoded/dropped frames)
    const q = readPlaybackQuality(v);
    sample.totalVideoFrames = q ? q.totalVideoFrames : null;
    sample.droppedVideoFrames = q ? q.droppedVideoFrames : null;

    // optional: buffered ranges (to detect rebuffering + buffer health)
    try {
      sample.buffered_start_s = v.buffered && v.buffered.length ? v.buffered.start(0) : null;
      sample.buffered_end_s = v.buffered && v.buffered.length ? v.buffered.end(0) : null;
      sample.buffered_seconds = (sample.buffered_end_s !== null && sample.currentTime_s !== null)
                                ? Math.max(0, sample.buffered_end_s - sample.currentTime_s)
                                : null;
    } catch(e) {
      sample.buffered_start_s = sample.buffered_end_s = sample.buffered_seconds = null;
    }

    // optional: player DOM info (Netflix debug overlay or player container)
    try {
      const debug = document.querySelector('.netflix-debug-ui-panel, .player-info, #player-debug');
      sample.debug_text = debug ? debug.innerText.replace(/\s+/g,' ') : null;
    } catch(e) {
      sample.debug_text = null;
    }

    window.__qoeLogger.samples.push(sample);
  }

  // public control functions
  window.startQoE = function(ms = 250) {
    if (window.__qoeLogger.running) {
      console.warn("QoE logger already running");
      return;
    }
    // take one immediately, then schedule
    takeSample();
    window.__qoeLogger.intervalId = setInterval(takeSample, ms);
    window.__qoeLogger.running = true;
    console.log("QoE logger started, sampling every", ms, "ms");
  };

  window.stopQoE = function() {
    if (!window.__qoeLogger.running) {
      console.warn("QoE logger is not running");
      return;
    }
    clearInterval(window.__qoeLogger.intervalId);
    window.__qoeLogger.intervalId = null;
    window.__qoeLogger.running = false;
    console.log("QoE logger stopped. Samples:", window.__qoeLogger.samples.length);
  };

  // export CSV
  window.downloadQoE = function() {
    const rows = window.__qoeLogger.samples;
    if (!rows || !rows.length) {
      console.warn("No samples to download");
      return;
    }
    // produce CSV header from keys of the first sample
    const keys = Object.keys(rows[0]);
    const csv = [
      keys.join(','),
      ...rows.map(r => keys.map(k => {
        const v = r[k];
        if (v === null || v === undefined) return '';
        // escape quotes
        return `"${String(v).replace(/"/g,'""')}"`;
      }).join(','))
    ].join('\r\n');

    const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'qoe_log.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    console.log("Download started: qoe_log.csv");
  };

  // utility: clear samples
  window.clearQoE = function() {
    window.__qoeLogger.samples = [];
    console.log("QoE samples cleared");
  };

  console.log("QoE logger ready. Use startQoE(ms), stopQoE(), downloadQoE(), clearQoE()");
})();
